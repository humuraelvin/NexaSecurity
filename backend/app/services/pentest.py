from datetime import datetime
from typing import Optional, List, Dict, Any
from motor.motor_asyncio import AsyncIOMotorDatabase
from bson import ObjectId
from fastapi import HTTPException, status
import asyncio
import socket
import subprocess
import platform
import json
import random
import time
import os
import requests

from app.models.base import PyObjectId
from app.models.pentest import (
    PentestType,
    PentestStatus,
    FindingSeverity,
    FindingStatus,
    PentestTarget,
    PentestFinding,
    PentestInput,
    PentestResponse,
    PentestOptions
)
from app.core.config import settings

class PenetrationTester:
    def __init__(self, db: AsyncIOMotorDatabase):
        self.db = db
        self.active_tests: Dict[str, asyncio.Task] = {}

    async def start_pentest(self, pentest_input: PentestInput, user_id: Optional[str] = None) -> Dict[str, Any]:
        """Start a new penetration test with the given configuration."""
        
        # Use local machine IP if target URL is not provided
        target_url = pentest_input.url if pentest_input.url else self._get_local_ip()
        
        # Create pentest document
        pentest_data = {
            "target": target_url,
            "type": pentest_input.type,
            "options": pentest_input.options.model_dump(),
            "status": PentestStatus.PENDING,
            "criticalVulnerabilities": 0,
            "mediumVulnerabilities": 0,
            "lowVulnerabilities": 0,
            "created_at": datetime.utcnow(),
            "updated_at": datetime.utcnow(),
        }
        
        if user_id:
            pentest_data["user_id"] = ObjectId(user_id) if isinstance(user_id, str) else user_id
        
        # Insert into database
        result = await self.db.pentests.insert_one(pentest_data)
        scan_id = str(result.inserted_id)
        
        # Start test in background
        self.active_tests[scan_id] = asyncio.create_task(
            self._run_test(scan_id)
        )
        
        return {"scanId": scan_id}

    async def get_pentest_status(self, scan_id: str) -> Dict[str, Any]:
        """Get the status of a running or completed penetration test."""
        if not ObjectId.is_valid(scan_id):
            raise HTTPException(status_code=400, detail="Invalid scan ID")
        
        pentest = await self.db.pentests.find_one({"_id": ObjectId(scan_id)})
        if not pentest:
            raise HTTPException(status_code=404, detail="Penetration test not found")
        
        progress = 0
        if pentest["status"] == PentestStatus.COMPLETED:
            progress = 100
        elif pentest["status"] == PentestStatus.IN_PROGRESS:
            # If in progress, calculate approximate progress
            started_at = pentest.get("start_time", pentest["created_at"])
            current_time = datetime.utcnow()
            elapsed = (current_time - started_at).total_seconds()
            
            # Estimate progress based on scan type
            if pentest["type"] == PentestType.QUICK:
                # Quick scan takes approximately 10 minutes
                total_duration = 10 * 60
            elif pentest["type"] == PentestType.STANDARD:
                # Standard scan takes approximately 30 minutes
                total_duration = 30 * 60
            elif pentest["type"] == PentestType.COMPREHENSIVE:
                # Comprehensive scan takes approximately 1-2 hours
                total_duration = 90 * 60
            else:
                # Default to 30 minutes
                total_duration = 30 * 60
            
            progress = min(95, (elapsed / total_duration) * 100)
        
        return {
            "completed": pentest["status"] == PentestStatus.COMPLETED,
            "progress": progress,
            "status": pentest["status"]
        }

    async def get_all_pentests(self, user_id: Optional[str] = None) -> List[PentestResponse]:
        """Get all penetration tests, optionally filtered by user."""
        query = {}
        if user_id:
            query["user_id"] = ObjectId(user_id) if isinstance(user_id, str) else user_id
        
        pentests = await self.db.pentests.find(query).sort("created_at", -1).to_list(100)
        for pentest in pentests:
            # Add formatted date for display
            pentest["date"] = pentest["created_at"].strftime("%B %d, %Y")
        
        return pentests

    async def get_pentest_results(self, scan_id: str) -> Dict[str, Any]:
        """Get the detailed results of a completed penetration test."""
        if not ObjectId.is_valid(scan_id):
            raise HTTPException(status_code=400, detail="Invalid scan ID")
        
        pentest = await self.db.pentests.find_one({"_id": ObjectId(scan_id)})
        if not pentest:
            raise HTTPException(status_code=404, detail="Penetration test not found")
        
        # Get findings for this pentest
        findings = await self.db.findings.find({"pentest_id": ObjectId(scan_id)}).to_list(100)
        pentest["findings"] = findings
        
        return pentest

    async def _run_test(self, scan_id: str) -> None:
        """Execute the penetration test in the background."""
        try:
            # Get pentest from database
            pentest = await self.db.pentests.find_one({"_id": ObjectId(scan_id)})
            if not pentest:
                return
            
            # Update status to in progress
            await self.db.pentests.update_one(
                {"_id": ObjectId(scan_id)},
                {
                    "$set": {
                        "status": PentestStatus.IN_PROGRESS,
                        "start_time": datetime.utcnow(),
                        "updated_at": datetime.utcnow()
                    }
                }
            )
            
            # Give the scan some time to "run" - simulate real scanning
            target = pentest["target"]
            scan_type = pentest["type"]
            scan_options = pentest["options"]
            
            # Get the local IP if the target is not specified
            if not target or target.strip() == "":
                target = self._get_local_ip()
                await self.db.pentests.update_one(
                    {"_id": ObjectId(scan_id)},
                    {"$set": {"target": target}}
                )
            
            # Run different types of scans based on the selected type
            await self._simulate_scan_delay(scan_type)
            
            # Generate findings based on scan type and options
            findings = await self._generate_findings(scan_id, target, scan_type, scan_options)
            
            # Calculate vulnerability counts
            critical_count = len([f for f in findings if f["severity"] == FindingSeverity.CRITICAL])
            medium_count = len([f for f in findings if f["severity"] == FindingSeverity.MEDIUM])
            low_count = len([f for f in findings if f["severity"] == FindingSeverity.LOW])
            
            # Update the pentest with results
            await self.db.pentests.update_one(
                {"_id": ObjectId(scan_id)},
                {
                    "$set": {
                        "status": PentestStatus.COMPLETED,
                        "criticalVulnerabilities": critical_count,
                        "mediumVulnerabilities": medium_count,
                        "lowVulnerabilities": low_count,
                        "end_time": datetime.utcnow(),
                        "updated_at": datetime.utcnow()
                    }
                }
            )
        except Exception as e:
            # Update status to failed
            await self.db.pentests.update_one(
                {"_id": ObjectId(scan_id)},
                {
                    "$set": {
                        "status": PentestStatus.FAILED,
                        "end_time": datetime.utcnow(),
                        "error": str(e),
                        "updated_at": datetime.utcnow()
                    }
                }
            )
        finally:
            # Remove from active tests
            self.active_tests.pop(scan_id, None)
    
    async def _simulate_scan_delay(self, scan_type: str):
        """Simulate a delay based on scan type to mimic real scanning."""
        if scan_type == PentestType.QUICK:
            await asyncio.sleep(10)  # 10 seconds for quick scan in demo
        elif scan_type == PentestType.STANDARD:
            await asyncio.sleep(15)  # 15 seconds for standard scan in demo
        elif scan_type == PentestType.COMPREHENSIVE:
            await asyncio.sleep(20)  # 20 seconds for comprehensive scan in demo
        elif scan_type == PentestType.WEBAPP:
            await asyncio.sleep(12)  # 12 seconds for web app scan in demo
        elif scan_type == PentestType.NETWORK:
            await asyncio.sleep(18)  # 18 seconds for network scan in demo
        else:  # Custom or other
            await asyncio.sleep(15)  # 15 seconds for custom scan in demo

    async def _generate_findings(self, pentest_id: str, target: str, scan_type: str, scan_options: Dict) -> List[Dict]:
        """Generate findings based on scan type and options."""
        findings = []
        
        # Port scan findings
        if scan_options.get("portScan", False):
            open_ports = await self._simulate_port_scan(target)
            for port, service in open_ports.items():
                finding = {
                    "pentest_id": ObjectId(pentest_id),
                    "title": f"Open port {port} ({service})",
                    "description": f"Port {port} is open and running {service}.",
                    "severity": FindingSeverity.LOW if port not in [22, 21, 23, 3389] else FindingSeverity.MEDIUM,
                    "status": FindingStatus.OPEN,
                    "affected_components": ["network", "firewall"],
                    "created_at": datetime.utcnow(),
                    "updated_at": datetime.utcnow()
                }
                findings.append(finding)
                await self.db.findings.insert_one(finding)
        
        # Vulnerability scan findings
        if scan_options.get("vulnScan", False):
            vulnerabilities = await self._simulate_vuln_scan(target, scan_type)
            for vuln in vulnerabilities:
                finding = {
                    "pentest_id": ObjectId(pentest_id),
                    "title": vuln["title"],
                    "description": vuln["description"],
                    "severity": vuln["severity"],
                    "status": FindingStatus.OPEN,
                    "affected_components": vuln.get("affected_components", ["application"]),
                    "remediation": vuln.get("remediation", "Update the affected component to the latest version."),
                    "created_at": datetime.utcnow(),
                    "updated_at": datetime.utcnow()
                }
                findings.append(finding)
                await self.db.findings.insert_one(finding)
        
        # SQL injection findings
        if scan_options.get("sqlInjection", False):
            sql_vulns = await self._simulate_sql_injection_scan(target)
            for vuln in sql_vulns:
                finding = {
                    "pentest_id": ObjectId(pentest_id),
                    "title": vuln["title"],
                    "description": vuln["description"],
                    "severity": vuln["severity"],
                    "status": FindingStatus.OPEN,
                    "affected_components": ["database", "application"],
                    "remediation": "Use parameterized queries and input validation.",
                    "created_at": datetime.utcnow(),
                    "updated_at": datetime.utcnow()
                }
                findings.append(finding)
                await self.db.findings.insert_one(finding)
        
        # XSS findings
        if scan_options.get("xss", False):
            xss_vulns = await self._simulate_xss_scan(target)
            for vuln in xss_vulns:
                finding = {
                    "pentest_id": ObjectId(pentest_id),
                    "title": vuln["title"],
                    "description": vuln["description"],
                    "severity": vuln["severity"],
                    "status": FindingStatus.OPEN,
                    "affected_components": ["frontend", "user-interface"],
                    "remediation": "Implement proper output encoding and CSP.",
                    "created_at": datetime.utcnow(),
                    "updated_at": datetime.utcnow()
                }
                findings.append(finding)
                await self.db.findings.insert_one(finding)
        
        # Brute force findings
        if scan_options.get("bruteForce", False) and scan_type in [PentestType.COMPREHENSIVE, PentestType.CUSTOM]:
            brute_force_vulns = await self._simulate_brute_force_scan(target)
            for vuln in brute_force_vulns:
                finding = {
                    "pentest_id": ObjectId(pentest_id),
                    "title": vuln["title"],
                    "description": vuln["description"],
                    "severity": vuln["severity"],
                    "status": FindingStatus.OPEN,
                    "affected_components": ["authentication"],
                    "remediation": "Implement account lockouts, rate limiting, and strong password policies.",
                    "created_at": datetime.utcnow(),
                    "updated_at": datetime.utcnow()
                }
                findings.append(finding)
                await self.db.findings.insert_one(finding)
        
        return findings

    async def _simulate_port_scan(self, target: str) -> Dict[int, str]:
        """Simulate a port scan and return open ports with services."""
        common_ports = {
            22: "SSH",
            80: "HTTP",
            443: "HTTPS",
            21: "FTP",
            25: "SMTP",
            110: "POP3",
            143: "IMAP",
            3306: "MySQL",
            5432: "PostgreSQL",
            27017: "MongoDB",
            8080: "HTTP-ALT"
        }
        
        # Randomly determine which ports are "open" based on scan
        open_ports = {}
        for port, service in common_ports.items():
            if random.random() < 0.3:  # 30% chance for each port to be "open"
                open_ports[port] = service
        
        # Always include at least port 80 (HTTP) as open
        if 80 not in open_ports:
            open_ports[80] = "HTTP"
        
        return open_ports

    async def _simulate_vuln_scan(self, target: str, scan_type: str) -> List[Dict]:
        """Simulate a vulnerability scan and return vulnerabilities."""
        # Define common vulnerabilities
        common_vulns = [
            {
                "title": "Outdated SSL/TLS Protocol",
                "description": "The server supports outdated SSL/TLS protocols (TLS 1.0, TLS 1.1) which have known security vulnerabilities.",
                "severity": FindingSeverity.MEDIUM,
                "remediation": "Disable TLS 1.0 and TLS 1.1, and use TLS 1.2 or higher."
            },
            {
                "title": "Web Server Information Disclosure",
                "description": "The web server is disclosing version information in HTTP headers, which could help attackers identify specific vulnerabilities.",
                "severity": FindingSeverity.LOW,
                "remediation": "Configure the web server to suppress version information in HTTP headers."
            },
            {
                "title": "Missing HTTP Security Headers",
                "description": "The application is missing important security headers like X-Content-Type-Options, X-Frame-Options, and Content-Security-Policy.",
                "severity": FindingSeverity.MEDIUM,
                "remediation": "Implement proper security headers in all HTTP responses."
            }
        ]
        
        # More serious vulnerabilities for standard and comprehensive scans
        serious_vulns = [
            {
                "title": "Insecure Deserialization",
                "description": "The application deserializes untrusted data without proper validation, which could lead to remote code execution.",
                "severity": FindingSeverity.CRITICAL,
                "remediation": "Implement integrity checks and validate deserialized data before using it."
            },
            {
                "title": "Server-Side Request Forgery (SSRF)",
                "description": "The application processes untrusted URLs without proper validation, which could allow attackers to make requests to internal services.",
                "severity": FindingSeverity.CRITICAL,
                "remediation": "Validate and sanitize all URLs, use allow-lists for external resources, and implement proper network segmentation."
            }
        ]
        
        # Select vulnerabilities based on scan type
        if scan_type == PentestType.QUICK:
            return random.sample(common_vulns, min(1, len(common_vulns)))
        elif scan_type == PentestType.STANDARD:
            vulnerabilities = random.sample(common_vulns, min(2, len(common_vulns)))
            vulnerabilities.extend(random.sample(serious_vulns, min(1, len(serious_vulns))))
            return vulnerabilities
        elif scan_type in [PentestType.COMPREHENSIVE, PentestType.CUSTOM]:
            return common_vulns + serious_vulns
        else:
            return random.sample(common_vulns, min(2, len(common_vulns)))

    async def _simulate_sql_injection_scan(self, target: str) -> List[Dict]:
        """Simulate an SQL injection scan and return vulnerabilities."""
        # Define SQL injection vulnerabilities
        sql_vulns = [
            {
                "title": "SQL Injection in Login Form",
                "description": "The login form is vulnerable to SQL injection, which could allow attackers to bypass authentication or extract sensitive data.",
                "severity": FindingSeverity.CRITICAL
            },
            {
                "title": "SQL Injection in Search Parameter",
                "description": "The search functionality is vulnerable to SQL injection, allowing attackers to access unauthorized data.",
                "severity": FindingSeverity.HIGH
            },
            {
                "title": "Blind SQL Injection",
                "description": "The application is vulnerable to blind SQL injection, which can be exploited to extract data using boolean or time-based techniques.",
                "severity": FindingSeverity.MEDIUM
            }
        ]
        
        # Return a subset of vulnerabilities
        return random.sample(sql_vulns, random.randint(0, len(sql_vulns)))

    async def _simulate_xss_scan(self, target: str) -> List[Dict]:
        """Simulate an XSS scan and return vulnerabilities."""
        # Define XSS vulnerabilities
        xss_vulns = [
            {
                "title": "Stored XSS in Comment System",
                "description": "User comments are not properly sanitized, allowing attackers to inject malicious scripts that are executed when other users view the comments.",
                "severity": FindingSeverity.CRITICAL
            },
            {
                "title": "Reflected XSS in Search Parameter",
                "description": "The search functionality reflects user input without proper encoding, allowing attackers to craft malicious URLs.",
                "severity": FindingSeverity.MEDIUM
            },
            {
                "title": "DOM-based XSS",
                "description": "The application uses user-controlled input to update the DOM through JavaScript, leading to XSS vulnerabilities.",
                "severity": FindingSeverity.MEDIUM
            }
        ]
        
        # Return a subset of vulnerabilities
        return random.sample(xss_vulns, random.randint(0, len(xss_vulns)))

    async def _simulate_brute_force_scan(self, target: str) -> List[Dict]:
        """Simulate a brute force scan and return vulnerabilities."""
        # Define brute force vulnerabilities
        brute_force_vulns = [
            {
                "title": "No Account Lockout Policy",
                "description": "The application does not lock accounts after multiple failed login attempts, making it vulnerable to brute force attacks.",
                "severity": FindingSeverity.HIGH
            },
            {
                "title": "Weak Password Policy",
                "description": "The application allows weak passwords, making accounts susceptible to password guessing attacks.",
                "severity": FindingSeverity.MEDIUM
            }
        ]
        
        # Randomly determine if vulnerabilities are found
        if random.random() < 0.7:  # 70% chance to find brute force vulnerabilities
            return random.sample(brute_force_vulns, random.randint(1, len(brute_force_vulns)))
        else:
            return []

    def _get_local_ip(self) -> str:
        """Get the local IP address of the machine."""
        try:
            # Create a socket and connect to an external server
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            local_ip = s.getsockname()[0]
            s.close()
            return local_ip
        except Exception:
            # Fallback if we can't determine the IP
            return "127.0.0.1" 