from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks, Query
from typing import Any, List, Optional, Dict
from app.core.database import get_database
from app.services.auth import get_current_user, get_current_active_user
from app.services.pentest import PenetrationTester
from app.models.user import UserInDB
from app.models.pentest import (
    PentestType, PentestStatus, PentestScope,
    FindingSeverity, FindingStatus, PentestCreate, PentestResponse, FindingCreate, FindingResponse,
    PentestInput, PentestTarget, PentestOptions
)
from pydantic import BaseModel, validator, HttpUrl
from datetime import datetime
import re
import ipaddress
import socket
from bson import ObjectId

router = APIRouter()

class PentestCreate(BaseModel):
    name: str
    target: str
    pentest_type: PentestType
    scope: PentestScope
    custom_tests: List[str]
    credentials: Optional[Dict[str, str]] = None
    exclusions: Optional[List[str]] = None

    @validator("name")
    def validate_name(cls, v):
        """Validate pentest name."""
        if not v or not re.match(r"^[a-zA-Z0-9_\- ]{3,50}$", v):
            raise ValueError("Invalid name format")
        return v

    @validator("target")
    def validate_target(cls, v):
        """Validate target URL or IP."""
        try:
            if v.startswith(("http://", "https://")):
                HttpUrl(v)
            else:
                ipaddress.ip_address(v)
        except (ValueError, AttributeError):
            raise ValueError("Invalid target. Must be valid URL or IP address")
        return v

class PentestResponse(BaseModel):
    id: int
    name: str
    target: str
    pentest_type: PentestType
    scope: PentestScope
    status: PentestStatus
    start_date: Optional[datetime]
    end_date: Optional[datetime]
    critical_findings: int
    high_findings: int
    medium_findings: int
    low_findings: int
    info_findings: int
    summary: Optional[dict]

class FindingCreate(BaseModel):
    title: str
    description: str
    severity: FindingSeverity
    vulnerability_type: str
    affected_components: List[str]
    steps_to_reproduce: List[str]
    impact: str
    remediation: str
    references: Optional[List[str]] = None

class FindingResponse(BaseModel):
    id: int
    title: str
    description: str
    severity: FindingSeverity
    status: FindingStatus
    vulnerability_type: str
    affected_components: List[str]
    attack_vector: Optional[str]
    impact: str
    steps_to_reproduce: List[str]
    poc_data: Optional[dict]
    remediation: str
    remediation_complexity: Optional[str]
    remediation_priority: Optional[int]
    is_verified: bool
    cwe_id: Optional[str]
    references: Optional[List[str]]

# Helper function to get the local machine's IP
def get_local_ip():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        local_ip = s.getsockname()[0]
        s.close()
        return local_ip
    except Exception:
        return "127.0.0.1"

@router.post("/", response_model=PentestResponse)
async def create_pentest(
    *,
    pentest_in: PentestCreate,
    background_tasks: BackgroundTasks,
    db = Depends(get_database),
    current_user: UserInDB = Depends(get_current_user)
) -> Any:
    """
    Create new penetration test.
    """
    # Check user's pentest limit
    today_start = datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)
    today_pentests_count = await db["pentests"].count_documents({
        "user_id": ObjectId(current_user.id),
        "created_at": {"$gte": today_start}
    })
    
    if today_pentests_count >= current_user.pentest_limit:
        raise HTTPException(
            status_code=429,
            detail="Daily penetration test limit reached"
        )
    
    # Create pentest record
    pentest_tester = PenetrationTester(db)
    pentest_id = await pentest_tester.create_pentest(
        name=pentest_in.name,
        target=pentest_in.target,
        pentest_type=pentest_in.pentest_type,
        scope=pentest_in.scope,
        custom_tests=pentest_in.custom_tests,
        credentials=pentest_in.credentials,
        exclusions=pentest_in.exclusions,
        user_id=current_user.id
    )
    
    # Get the created pentest
    pentest = await db["pentests"].find_one({"_id": pentest_id})
    
    return {**pentest, "id": str(pentest["_id"])}

@router.get("/{pentest_id}", response_model=PentestResponse)
async def get_pentest(
    pentest_id: str,
    db = Depends(get_database),
    current_user: UserInDB = Depends(get_current_user)
) -> Any:
    """
    Get penetration test by ID.
    """
    pentest = await db["pentests"].find_one({
        "_id": ObjectId(pentest_id),
        "user_id": ObjectId(current_user.id)
    })
    
    if not pentest:
        raise HTTPException(
            status_code=404,
            detail="Penetration test not found"
        )
    
    return {**pentest, "id": str(pentest["_id"])}

@router.get("/{pentest_id}/findings", response_model=List[FindingResponse])
async def get_pentest_findings(
    pentest_id: str,
    severity: Optional[FindingSeverity] = None,
    status: Optional[FindingStatus] = None,
    db = Depends(get_database),
    current_user: UserInDB = Depends(get_current_user)
) -> Any:
    """
    Get findings from penetration test.
    """
    # Check pentest exists and belongs to user
    pentest = await db["pentests"].find_one({
        "_id": ObjectId(pentest_id),
        "user_id": ObjectId(current_user.id)
    })
    
    if not pentest:
        raise HTTPException(
            status_code=404,
            detail="Penetration test not found"
        )
    
    # Query findings
    query = {"pentest_id": ObjectId(pentest_id)}
    
    if severity:
        query["severity"] = severity
    if status:
        query["status"] = status
    
    cursor = db["findings"].find(query)
    findings = await cursor.to_list(length=100)
    
    # Format the response
    return [{**finding, "id": str(finding["_id"])} for finding in findings]

@router.post("/{pentest_id}/findings", response_model=FindingResponse)
async def create_finding(
    pentest_id: str,
    finding_in: FindingCreate,
    db = Depends(get_database),
    current_user: UserInDB = Depends(get_current_user)
) -> Any:
    """
    Add finding to penetration test.
    """
    # Check pentest exists and belongs to user
    pentest = await db["pentests"].find_one({
        "_id": ObjectId(pentest_id),
        "user_id": ObjectId(current_user.id)
    })
    
    if not pentest:
        raise HTTPException(
            status_code=404,
            detail="Penetration test not found"
        )
    
    # Create finding
    pentest_tester = PenetrationTester(db)
    finding_id = await pentest_tester.create_finding(
        pentest_id=ObjectId(pentest_id),
        title=finding_in.title,
        description=finding_in.description,
        severity=finding_in.severity,
        vulnerability_type=finding_in.vulnerability_type,
        affected_components=finding_in.affected_components,
        steps_to_reproduce=finding_in.steps_to_reproduce,
        impact=finding_in.impact,
        remediation=finding_in.remediation,
        references=finding_in.references
    )
    
    # Get created finding
    finding = await db["findings"].find_one({"_id": finding_id})
    
    return {**finding, "id": str(finding["_id"])}

@router.put("/{pentest_id}/findings/{finding_id}", response_model=FindingResponse)
async def update_finding(
    pentest_id: str,
    finding_id: str,
    finding_in: FindingCreate,
    db = Depends(get_database),
    current_user: UserInDB = Depends(get_current_user)
) -> Any:
    """
    Update finding details.
    """
    # Check pentest exists and belongs to user
    pentest = await db["pentests"].find_one({
        "_id": ObjectId(pentest_id),
        "user_id": ObjectId(current_user.id)
    })
    
    if not pentest:
        raise HTTPException(
            status_code=404,
            detail="Penetration test not found"
        )
    
    # Get finding
    finding = await db["findings"].find_one({
        "_id": ObjectId(finding_id),
        "pentest_id": ObjectId(pentest_id)
    })
    
    if not finding:
        raise HTTPException(
            status_code=404,
            detail="Finding not found"
        )
    
    # Update finding using the PenetrationTester service
    pentest_tester = PenetrationTester(db)
    updated_finding_id = await pentest_tester.update_finding(
        finding_id=ObjectId(finding_id),
        pentest_id=ObjectId(pentest_id),
        title=finding_in.title,
        description=finding_in.description,
        severity=finding_in.severity,
        vulnerability_type=finding_in.vulnerability_type,
        affected_components=finding_in.affected_components,
        steps_to_reproduce=finding_in.steps_to_reproduce,
        impact=finding_in.impact,
        remediation=finding_in.remediation,
        references=finding_in.references
    )
    
    # Get updated finding
    updated_finding = await db["findings"].find_one({"_id": updated_finding_id})
    
    return {**updated_finding, "id": str(updated_finding["_id"])}

@router.get("/{pentest_id}/status")
async def get_pentest_status(
    pentest_id: str,
    db = Depends(get_database),
    current_user: UserInDB = Depends(get_current_user)
) -> Any:
    """
    Get penetration test status and progress.
    """
    pentest = await db["pentests"].find_one({
        "_id": ObjectId(pentest_id),
        "user_id": ObjectId(current_user.id)
    })
    
    if not pentest:
        raise HTTPException(
            status_code=404,
            detail="Penetration test not found"
        )
    
    progress = None
    if pentest["status"] == PentestStatus.IN_PROGRESS:
        pentest_tester = PenetrationTester(db)
        progress = await pentest_tester.get_test_progress(pentest_id)
    
    return {
        "status": pentest["status"],
        "progress": progress,
        "findings_summary": {
            "critical": pentest.get("critical_findings", 0),
            "high": pentest.get("high_findings", 0),
            "medium": pentest.get("medium_findings", 0),
            "low": pentest.get("low_findings", 0),
            "info": pentest.get("info_findings", 0)
        }
    }

@router.post("/{pentest_id}/cancel")
async def cancel_pentest(
    pentest_id: str,
    db = Depends(get_database),
    current_user: UserInDB = Depends(get_current_user)
) -> Any:
    """
    Cancel running penetration test.
    """
    pentest = await db["pentests"].find_one({
        "_id": ObjectId(pentest_id),
        "user_id": ObjectId(current_user.id)
    })
    
    if not pentest:
        raise HTTPException(
            status_code=404,
            detail="Penetration test not found"
        )
    
    if pentest["status"] != PentestStatus.IN_PROGRESS:
        raise HTTPException(
            status_code=400,
            detail="Can only cancel tests in progress"
        )
    
    # Cancel test
    pentest_tester = PenetrationTester(db)
    await pentest_tester.cancel_test(pentest_id)
    
    return {"message": "Penetration test cancelled successfully"}

@router.get("/", response_model=List[PentestResponse])
async def list_pentests(
    skip: int = 0,
    limit: int = 10,
    status: Optional[PentestStatus] = None,
    db = Depends(get_database),
    current_user: UserInDB = Depends(get_current_user)
) -> Any:
    """
    List user's penetration tests.
    """
    query = {"user_id": ObjectId(current_user.id)}
    
    if status:
        query["status"] = status
    
    cursor = db["pentests"].find(query).skip(skip).limit(limit).sort("created_at", -1)
    pentests = await cursor.to_list(length=limit)
    
    # Format the response
    return [{**pentest, "id": str(pentest["_id"])} for pentest in pentests]

@router.post("/start")
async def start_pentest(
    pentest_in: PentestInput,
    background_tasks: BackgroundTasks,
    db = Depends(get_database),
    current_user: Optional[UserInDB] = Depends(get_current_active_user)
) -> Dict[str, Any]:
    """
    Start a new penetration test.
    """
    # If URL is not provided, use local IP
    if not pentest_in.url or pentest_in.url.strip() == "":
        pentest_in.url = get_local_ip()
    
    # Create pentest service
    pentest_service = PenetrationTester(db)
    
    # Start test
    user_id = str(current_user.id) if current_user else None
    result = await pentest_service.start_pentest(pentest_in, user_id)
    
    return result

@router.get("/{scanId}/status")
async def get_pentest_status(
    scanId: str,
    db = Depends(get_database),
    current_user: Optional[UserInDB] = Depends(get_current_active_user)
) -> Dict[str, Any]:
    """
    Get the status of a penetration test.
    """
    # Create pentest service
    pentest_service = PenetrationTester(db)
    
    # Get status
    return await pentest_service.get_pentest_status(scanId)

@router.get("/{scanId}/results")
async def get_pentest_results(
    scanId: str,
    db = Depends(get_database),
    current_user: Optional[UserInDB] = Depends(get_current_active_user)
) -> Dict[str, Any]:
    """
    Get the results of a penetration test.
    """
    # Create pentest service
    pentest_service = PenetrationTester(db)
    
    # Get results
    result = await pentest_service.get_pentest_results(scanId)
    
    # Format the response to match frontend expectations
    formatted_result = {
        "id": str(result["_id"]),
        "target": result["target"],
        "type": result["type"],
        "status": result["status"],
        "date": result.get("date") or result["created_at"].strftime("%B %d, %Y"),
        "criticalVulnerabilities": result.get("criticalVulnerabilities", 0),
        "mediumVulnerabilities": result.get("mediumVulnerabilities", 0),
        "lowVulnerabilities": result.get("lowVulnerabilities", 0),
        "findings": []
    }
    
    # Format findings
    for finding in result.get("findings", []):
        formatted_finding = {
            "id": str(finding["_id"]),
            "title": finding["title"],
            "description": finding["description"],
            "severity": finding["severity"],
            "status": finding.get("status", FindingStatus.OPEN)
        }
        formatted_result["findings"].append(formatted_finding)
    
    return formatted_result

@router.get("/")
async def get_all_pentests(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=100),
    db = Depends(get_database),
    current_user: Optional[UserInDB] = Depends(get_current_active_user)
) -> List[Dict[str, Any]]:
    """
    Get all penetration tests for the current user.
    """
    # Create pentest service
    pentest_service = PenetrationTester(db)
    
    # Get all pentests
    user_id = str(current_user.id) if current_user else None
    pentests = await pentest_service.get_all_pentests(user_id)
    
    # Format the response to match frontend expectations
    formatted_results = []
    for pentest in pentests:
        formatted_pentest = {
            "id": str(pentest["_id"]),
            "target": pentest["target"],
            "type": pentest["type"],
            "status": pentest["status"],
            "date": pentest.get("date") or pentest["created_at"].strftime("%B %d, %Y"),
            "criticalVulnerabilities": pentest.get("criticalVulnerabilities", 0),
            "mediumVulnerabilities": pentest.get("mediumVulnerabilities", 0),
            "lowVulnerabilities": pentest.get("lowVulnerabilities", 0)
        }
        formatted_results.append(formatted_pentest)
    
    return formatted_results

@router.get("/{scanId}/download")
async def download_pentest_report(
    scanId: str,
    db = Depends(get_database),
    current_user: Optional[UserInDB] = Depends(get_current_active_user)
) -> Dict[str, Any]:
    """
    Generate and download a penetration test report.
    """
    # Check if the pentest exists
    if not ObjectId.is_valid(scanId):
        raise HTTPException(status_code=400, detail="Invalid scan ID")
    
    pentest = await db.pentests.find_one({"_id": ObjectId(scanId)})
    if not pentest:
        raise HTTPException(status_code=404, detail="Penetration test not found")
    
    # Simple response for now - this would be expanded to generate a real report
    return {
        "report": {
            "id": str(pentest["_id"]),
            "generated_at": datetime.utcnow().isoformat(),
            "title": f"Penetration Test Report for {pentest['target']}",
            "summary": f"This is a sample report for the {pentest['type']} scan performed on {pentest['target']}.",
            "findings_count": {
                "critical": pentest.get("criticalVulnerabilities", 0),
                "medium": pentest.get("mediumVulnerabilities", 0),
                "low": pentest.get("lowVulnerabilities", 0),
                "total": (
                    pentest.get("criticalVulnerabilities", 0) + 
                    pentest.get("mediumVulnerabilities", 0) + 
                    pentest.get("lowVulnerabilities", 0)
                )
            }
        }
    } 