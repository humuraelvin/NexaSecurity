from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from sqlalchemy.orm import Session
from typing import List
from ..database.database import get_db
from ..schemas.pentests import PentestTarget, PentestStartResponse, PentestStatus, PentestResult
from ..core.security import get_current_user
from ..schemas.auth import User
from ..models.pentest import Pentest
import uuid
import random
import asyncio
from datetime import datetime, timedelta

router = APIRouter(
    prefix="/pentests",
    tags=["Penetration Testing"],
)

# Mock data for pentests
MOCK_PENTEST_FINDINGS = [
    {
        "id": "pf1",
        "title": "Insecure Direct Object Reference",
        "description": "IDOR vulnerability allows unauthorized access to user data.",
        "severity": "high",
        "affected_component": "User Profile API",
        "type": "access-control",
        "cve_id": None,
        "remediation": "Implement proper access control checks for all user data endpoints."
    },
    {
        "id": "pf2",
        "title": "Broken Authentication",
        "description": "Weak session management allows session fixation attacks.",
        "severity": "critical",
        "affected_component": "Authentication System",
        "type": "authentication",
        "cve_id": None,
        "remediation": "Regenerate session IDs after login and implement proper session timeout."
    },
    {
        "id": "pf3",
        "title": "Security Misconfiguration",
        "description": "Default error pages reveal sensitive system information.",
        "severity": "medium",
        "affected_component": "Web Server",
        "type": "configuration",
        "cve_id": None,
        "remediation": "Implement custom error pages and disable debug information in production."
    }
]

# Store active pentests
active_pentests = {}

@router.post("/start", response_model=PentestStartResponse)
async def start_pentest(
    target: PentestTarget,
    background_tasks: BackgroundTasks,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Start a new penetration test"""
    # Create a new pentest
    pentest_id = str(uuid.uuid4())
    
    # In a real application, this would be stored in the database
    new_pentest = Pentest(
        id=pentest_id,
        user_id=current_user.id,
        target=target.url,
        scan_type=target.type,
        status="running",
        progress=0,
        current_step="Initializing",
        estimated_time_remaining=300
    )
    
    db.add(new_pentest)
    db.commit()
    
    # Start background task to simulate the pentest
    background_tasks.add_task(run_pentest_task, pentest_id, db)
    
    return PentestStartResponse(
        scanId=pentest_id,
        message=f"Penetration test started for {target.url}"
    )

async def run_pentest_task(pentest_id: str, db: Session):
    """Background task to simulate a penetration test"""
    pentest = db.query(Pentest).filter(Pentest.id == pentest_id).first()
    if not pentest:
        return
    
    # Get the scan type to determine what kinds of findings to generate
    scan_type = pentest.scan_type
    target = pentest.target
    
    # Simulate progress
    steps = [
        "Reconnaissance",
        "Scanning",
        "Vulnerability Assessment",
        "Exploitation",
        "Post Exploitation",
        "Reporting"
    ]
    
    total_steps = len(steps)
    for i, step in enumerate(steps):
        # Update progress
        progress = int((i / total_steps) * 100)
        remaining = int(300 * (1 - progress/100))
        
        pentest.status = "running"
        pentest.progress = progress
        pentest.current_step = step
        pentest.estimated_time_remaining = remaining
        db.commit()
        
        # Simulate work - longer steps for certain phases
        if step == "Scanning" or step == "Exploitation":
            await asyncio.sleep(3)
        else:
            await asyncio.sleep(2)
    
    # Generate realistic findings based on scan type
    findings = generate_pentest_findings(scan_type, target)
    
    # Count findings by severity
    critical = sum(1 for f in findings if f.get("severity") == "critical")
    high = sum(1 for f in findings if f.get("severity") == "high")
    medium = sum(1 for f in findings if f.get("severity") == "medium")
    low = sum(1 for f in findings if f.get("severity") == "low")
    total = len(findings)
    
    # Complete the pentest with real findings
    pentest.status = "completed"
    pentest.progress = 100
    pentest.current_step = "Completed"
    pentest.end_time = datetime.now()
    pentest.findings = findings
    
    # Create summary based on actual findings
    if total > 0:
        summary_parts = []
        if critical > 0:
            summary_parts.append(f"{critical} critical")
        if high > 0:
            summary_parts.append(f"{high} high")
        if medium > 0:
            summary_parts.append(f"{medium} medium")
        if low > 0:
            summary_parts.append(f"{low} low")
        
        summary_text = ", ".join(summary_parts)
        pentest.summary = f"Penetration test identified {total} vulnerabilities ({summary_text}) in {target}."
    else:
        pentest.summary = f"Penetration test completed for {target}. No vulnerabilities were found."
    
    pentest.total_findings = total
    pentest.critical_findings = critical
    pentest.high_findings = high
    pentest.medium_findings = medium
    pentest.low_findings = low
    pentest.estimated_time_remaining = 0
    
    db.commit()

def generate_pentest_findings(scan_type: str, target: str):
    """Generate realistic pentest findings based on scan type and target"""
    import random
    from datetime import datetime
    
    # Common base findings that could apply to any pentest
    base_findings = [
        {
            "id": str(uuid.uuid4()),
            "title": "Insecure Direct Object Reference",
            "description": "IDOR vulnerability allows unauthorized access to user data by manipulating resource identifiers.",
            "severity": "high",
            "affected_component": "User Profile API",
            "type": "access-control",
            "cve_id": None,
            "remediation": "Implement proper access control checks for all user data endpoints. Use indirect references and validate user permissions before accessing resources."
        },
        {
            "id": str(uuid.uuid4()),
            "title": "Broken Authentication",
            "description": "Weak session management allows session fixation attacks and potential account takeover.",
            "severity": "critical",
            "affected_component": "Authentication System",
            "type": "authentication",
            "cve_id": None,
            "remediation": "Regenerate session IDs after login, implement proper session timeout, and add multi-factor authentication for sensitive operations."
        },
        {
            "id": str(uuid.uuid4()),
            "title": "Security Misconfiguration",
            "description": "Default error pages reveal sensitive system information that could aid attackers in fingerprinting the application.",
            "severity": "medium",
            "affected_component": "Web Server",
            "type": "configuration",
            "cve_id": None,
            "remediation": "Implement custom error pages and disable debug information in production environments."
        }
    ]
    
    # Specialized findings by scan type
    web_findings = [
        {
            "id": str(uuid.uuid4()),
            "title": "Cross-Site Scripting (XSS)",
            "description": f"Reflected XSS vulnerability found in search functionality on {target} allows attackers to inject malicious scripts.",
            "severity": "high",
            "affected_component": "Search Module",
            "type": "injection",
            "cve_id": None,
            "remediation": "Implement proper output encoding, use Content-Security-Policy headers, and sanitize user input."
        },
        {
            "id": str(uuid.uuid4()),
            "title": "SQL Injection",
            "description": f"SQL injection vulnerability in login form on {target} could allow authentication bypass and data extraction.",
            "severity": "critical",
            "affected_component": "Authentication Module",
            "type": "injection",
            "cve_id": None,
            "remediation": "Use prepared statements, parameterized queries, and ORM frameworks. Apply principle of least privilege for database users."
        },
        {
            "id": str(uuid.uuid4()),
            "title": "Cross-Site Request Forgery (CSRF)",
            "description": f"CSRF vulnerability in account settings page on {target} allows attackers to perform actions on behalf of authenticated users.",
            "severity": "medium",
            "affected_component": "User Account Settings",
            "type": "session-management",
            "cve_id": None,
            "remediation": "Implement anti-CSRF tokens for all state-changing operations and validate them server-side."
        },
        {
            "id": str(uuid.uuid4()),
            "title": "Sensitive Data Exposure",
            "description": f"API endpoints on {target} expose sensitive user information without proper authentication.",
            "severity": "high",
            "affected_component": "API Backend",
            "type": "data-protection",
            "cve_id": None,
            "remediation": "Encrypt sensitive data in transit and at rest. Implement proper access controls for all API endpoints that return sensitive data."
        }
    ]
    
    api_findings = [
        {
            "id": str(uuid.uuid4()),
            "title": "Improper API Authentication",
            "description": f"API endpoints on {target} use weak authentication mechanisms that could be bypassed.",
            "severity": "high",
            "affected_component": "API Gateway",
            "type": "authentication",
            "cve_id": None,
            "remediation": "Implement OAuth 2.0 or JWT-based authentication with proper signature validation and expiration."
        },
        {
            "id": str(uuid.uuid4()),
            "title": "Excessive Data Exposure",
            "description": f"API responses from {target} include sensitive fields that should be filtered before returning to clients.",
            "severity": "medium",
            "affected_component": "API Data Layer",
            "type": "data-protection",
            "cve_id": None,
            "remediation": "Implement a response filtering mechanism to ensure only necessary data is returned. Use field-level permissions."
        },
        {
            "id": str(uuid.uuid4()),
            "title": "Rate Limiting Bypass",
            "description": f"API rate limiting on {target} can be bypassed by manipulating request headers.",
            "severity": "medium",
            "affected_component": "API Gateway",
            "type": "security-controls",
            "cve_id": None,
            "remediation": "Implement server-side rate limiting that cannot be circumvented by client-side manipulation."
        }
    ]
    
    network_findings = [
        {
            "id": str(uuid.uuid4()),
            "title": "Insecure Network Service",
            "description": f"Outdated SMTP server running on {target} with known vulnerabilities.",
            "severity": "high",
            "affected_component": "Mail Server",
            "type": "outdated-software",
            "cve_id": "CVE-2019-10149",
            "remediation": "Update mail server software to the latest stable version and apply security patches regularly."
        },
        {
            "id": str(uuid.uuid4()),
            "title": "Open SMB Ports",
            "description": f"SMB service on {target} is accessible from untrusted networks and uses weak configuration.",
            "severity": "high",
            "affected_component": "File Sharing Services",
            "type": "network-exposure",
            "cve_id": None,
            "remediation": "Restrict SMB access to trusted networks only and ensure proper authentication is required."
        },
        {
            "id": str(uuid.uuid4()),
            "title": "Weak SSH Configuration",
            "description": f"SSH server on {target} allows weak cipher suites and password authentication.",
            "severity": "medium",
            "affected_component": "SSH Service",
            "type": "configuration",
            "cve_id": None,
            "remediation": "Configure SSH to use only strong ciphers, disable password authentication, and implement key-based authentication."
        },
        {
            "id": str(uuid.uuid4()),
            "title": "Unencrypted Telnet Service",
            "description": f"Telnet service running on {target} transmits credentials in cleartext.",
            "severity": "critical",
            "affected_component": "Remote Access Service",
            "type": "encryption",
            "cve_id": None,
            "remediation": "Replace Telnet with SSH for secure remote administration."
        }
    ]
    
    # Determine which findings to use based on scan type
    findings_pool = base_findings.copy()
    
    if scan_type.lower() in ["web", "webapp", "webscan"]:
        findings_pool.extend(web_findings)
    
    if scan_type.lower() in ["api", "apiscan"]:
        findings_pool.extend(api_findings)
    
    if scan_type.lower() in ["network", "networkscan", "infrastructure"]:
        findings_pool.extend(network_findings)
    
    if scan_type.lower() in ["full", "comprehensive"]:
        findings_pool.extend(web_findings)
        findings_pool.extend(api_findings)
        findings_pool.extend(network_findings)
    
    # Select a random subset of findings
    # More findings for comprehensive scans, fewer for focused scans
    if scan_type.lower() in ["full", "comprehensive"]:
        num_findings = random.randint(4, 10)
    else:
        num_findings = random.randint(2, 5)
    
    # Ensure we don't try to select more findings than we have in the pool
    num_findings = min(num_findings, len(findings_pool))
    selected_findings = random.sample(findings_pool, num_findings)
    
    # Add timestamps to findings
    current_time = datetime.now()
    for finding in selected_findings:
        finding["discovered_at"] = current_time.isoformat()
    
    return selected_findings

@router.get("/{pentest_id}/status", response_model=PentestStatus)
async def get_pentest_status(
    pentest_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get the status of a penetration test"""
    pentest = db.query(Pentest).filter(Pentest.id == pentest_id).first()
    
    if not pentest:
        raise HTTPException(status_code=404, detail="Pentest not found")
    
    if pentest.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to access this pentest")
    
    return PentestStatus(
        completed=pentest.status == "completed",
        progress=pentest.progress,
        current_step=pentest.current_step,
        estimated_time_remaining=pentest.estimated_time_remaining
    )

@router.get("/{pentest_id}/results", response_model=PentestResult)
async def get_pentest_results(
    pentest_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get the results of a completed penetration test"""
    pentest = db.query(Pentest).filter(Pentest.id == pentest_id).first()
    
    if not pentest:
        raise HTTPException(status_code=404, detail="Pentest not found")
    
    if pentest.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to access this pentest")
    
    if pentest.status != "completed":
        raise HTTPException(status_code=400, detail="Pentest is not completed yet")
    
    return PentestResult(
        id=pentest.id,
        target=pentest.target,
        start_time=pentest.start_time,
        end_time=pentest.end_time,
        status=pentest.status,
        summary=pentest.summary or "",
        findings=pentest.findings or [],
        scan_type=pentest.scan_type,
        total_findings=pentest.total_findings,
        critical_findings=pentest.critical_findings,
        high_findings=pentest.high_findings,
        medium_findings=pentest.medium_findings,
        low_findings=pentest.low_findings
    )

@router.get("", response_model=List[PentestResult])
async def get_all_pentests(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get all pentests for the current user"""
    pentests = db.query(Pentest).filter(Pentest.user_id == current_user.id).all()
    
    return [
        PentestResult(
            id=pentest.id,
            target=pentest.target,
            start_time=pentest.start_time,
            end_time=pentest.end_time,
            status=pentest.status,
            summary=pentest.summary or "",
            findings=pentest.findings or [],
            scan_type=pentest.scan_type,
            total_findings=pentest.total_findings,
            critical_findings=pentest.critical_findings,
            high_findings=pentest.high_findings,
            medium_findings=pentest.medium_findings,
            low_findings=pentest.low_findings
        )
        for pentest in pentests
    ]

@router.get("/{pentest_id}/download")
async def download_pentest_report(
    pentest_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Download the report for a completed penetration test"""
    pentest = db.query(Pentest).filter(Pentest.id == pentest_id).first()
    
    if not pentest:
        raise HTTPException(status_code=404, detail="Pentest not found")
    
    if pentest.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to access this pentest")
    
    if pentest.status != "completed":
        raise HTTPException(status_code=400, detail="Pentest is not completed yet")
    
    # In a real application, generate and return the actual PDF report
    return {
        "status": "success",
        "message": "Report download link generated",
        "link": f"/api/reports/pentest-{pentest_id}.pdf"
    } 